warning("\n", q, "matched multiple cantons! q", " returned.")
}
if(length(nrow) == 1) {
q <- as.character(canton_CH[unique(nrow[,1]),output])
}
q <- query[i]
nrow <- which(q == canton_CH, T)
if(length(nrow) == 0) {
warning("\n", q, " could not be matched!", q, " returned instead!")
}
if(length(unique(nrow[,1])) > 1) {
warning("\n", q, " matched multiple cantons!", q, " returned instead!")
}
if(length(nrow) == 1) {
q <- as.character(canton_CH[unique(nrow[,1]),output])
}
q
result <- query
for(i in 1:length(query)) {
q <- query[i]
nrow <- which(q == canton_CH, T)
if(length(nrow) == 0) {
warning("\n", q, " could not be matched!", q, " returned instead!")
}
if(length(unique(nrow[,1])) > 1) {
warning("\n", q, " matched multiple cantons!", q, " returned instead!")
}
if(length(nrow) == 1) {
q <- as.character(canton_CH[unique(nrow[,1]),output])
}
result[i] <- q
}
result
i <- 1
q <- query[i]
nrow <- which(q == canton_CH, T)
if(length(nrow) == 0) {
warning("\n", q, " could not be matched!", q, " returned instead!")
}
if(length(unique(nrow[,1])) > 1) {
warning("\n", q, " matched multiple cantons!", q, " returned instead!")
}
if(length(nrow) == 1) {
q <- as.character(canton_CH[unique(nrow[,1]),output])
}
result[i] <- q
result
i
result[i]
length(nrow)
nrow
result <- query
for(i in 1:length(query)) {
q <- query[i]
nrow <- which(q == canton_CH, T)
if(length(nrow) == 0) {
warning("\n", q, " could not be matched!", q, " returned instead!")
}
if(length(unique(nrow[,1])) > 1) {
warning("\n", q, " matched multiple cantons!", q, " returned instead!")
}
if(length(unique(nrow[,1])) == 1) {
q <- as.character(canton_CH[unique(nrow[,1]),output])
}
result[i] <- q
}
result
result <- query
for(i in 1:length(query)) {
q <- query[i]
nrow <- which(q == canton_CH, T)
if(length(nrow) == 0) {
warning("\n", q, " could not be matched!\t", q, " returned instead!")
}
if(length(unique(nrow[,1])) > 1) {
warning("\n", q, " matched multiple cantons!\t", q, " returned instead!")
}
if(length(unique(nrow[,1])) == 1) {
q <- as.character(canton_CH[unique(nrow[,1]),output])
} else {
q <- NA
}
result[i] <- q
}
result
result <- query
for(i in 1:length(query)) {
q <- query[i]
nrow <- which(q == canton_CH, T)
if(length(nrow) == 0) {
warning("\n", q, " could not be matched!\t", "NA returned instead!")
}
if(length(unique(nrow[,1])) > 1) {
warning("\n", q, " matched multiple cantons!\t", "NA returned instead!")
}
if(length(unique(nrow[,1])) == 1) {
q <- as.character(canton_CH[unique(nrow[,1]),output])
} else {
q <- NA
}
result[i] <- q
}
library(swiMap)
canton_CH
canton_namesStrict(canton_query, output = "english")
library(swiMap)
canton_namesStrict
?canton_namesStrict
canton_query <- c('Argovie', 'Appenzell Rh.-I.', 'St. Gallen', 'Zürich', 'randomChar', 'Vaudx')
canton_namesStrict(canton_query)
canton_namesStrict(canton_query, output = "english")
canton_namesStrict(canton_query, "iso2")
result <- query
for(i in 1:length(query)) {
q <- query[i]
nrow <- which(q == canton_CH, T)
if(length(nrow) == 0) {
warning("\n", q, " could not be matched!\t", "NA returned instead!")
}
if(length(unique(nrow[,1])) > 1) {
warning("\n", q, " matched multiple cantons!\t", "NA returned instead!")
}
if(length(unique(nrow[,1])) == 1) {
q <- as.character(canton_CH[unique(nrow[,1]),output])
} else {
q <- NA
}
result[i] <- q
}
result
stopifnot(exists("canton_CH"))
if (!output %in% colnames(canton_CH) || length(output) != 1) {
stop ("output needs to be one of:", paste(colnames(canton_CH), collapse =" "))
}
result <- query
for(i in 1:length(query)) {
q <- query[i]
nrow <- which(q == canton_CH, T)
if(length(nrow) == 0) {
warning("\n", q, " could not be matched!\t", "NA returned instead!")
}
if(length(unique(nrow[,1])) > 1) {
warning("\n", q, " matched multiple cantons!\t", "NA returned instead!")
}
if(length(unique(nrow[,1])) == 1) {
q <- as.character(canton_CH[unique(nrow[,1]),output])
} else {
q <- NA
}
result[i] <- q
}
result
result
library(swiMap)
canton_query <- c('Argovie', 'Appenzell Rh.-I.', 'St. Gallen', 'Zürich', 'randomChar', 'Vaudx')
canton_namesStrict(canton_query)
canton_namesStrict(canton_query, output = "english")
library(swiMap)
library(swiMap)
?canton_namesStrict
canton_query <- c('Argovie', 'Appenzell Rh.-I.', 'St. Gallen', 'Zürich', 'randomChar', 'Vaudx')
canton_namesStrict(canton_query)
canton_namesStrict(canton_query, output = "english")
library(swiMap)
canton_query <- c('Argovie', 'Appenzell Rh.-I.', 'St. Gallen', 'Zürich', 'randomChar', 'Vaudx')
canton_namesStrict(canton_query)
canton_namesStrict(canton_query, output = "english")
canton_namesStrict
library(swiMap)
library(swiMap)
library(swiMap)
?canton_namesStrict
canton_namesStrict
library(swiMap)
library(swiMap)
?canton_namesStrict
print(canton_CH)
canton_query <- c('Argovie', 'Appenzell Rh.-I.', 'St. Gallen', 'Zürich', 'randomChar', 'Vaudx')
canton_namesStrict(canton_query)
canton_namesStrict(canton_query, output = "english")
canton_namesStrict
library(swiMap)
canton_namesStrict
library(swiMap)
library(swiMap)
canton_namesStrict
library(swiMap)
library(swiMap)
canton_namesStrict
library(swiMap)
?formatShp
library(swiMap)
library(swiMap)
library(swiMap)
library(swiMap)
library(swiMap)
library(swiMap)
library(swiMap)
library(swiMap)
library(swiMap)
?getShpLayers
require(rgdal)
require(rgeos)
require(ggplot2)
path <- getPathShp('world')
layers <-  ogrListLayers(path)
layers
layers[1]
world <- readOGR(path, layer = layers[1])
world.df <- formatShp(world)
# plot world map
ggplot(world.df, aes(x = long, y = lat, group = group)) + geom_polygon(size = 0.01, aes(fill = FIPS)) +
theme_minimal() + theme(legend.position = "none", panel.grid = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), axis.text = element_blank())
Same with swiss commune map (slow!)
path.ch <- getPathShp('CH')
ch <- readOGR(path.ch, layer = 'municipalities')
ch.df <- formatShp(ch)
# plot swiss commune map
ch.communes <- ggplot(ch.df, aes(x = long, y = lat, group = group)) + geom_polygon(size = 0.01, aes(fill = GEMNAME)) +
theme_minimal() + theme(legend.position = "none", panel.grid = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), axis.text = element_blank())
ch.communes
# add the lake and country contours
lake.df <- formatShp(readOGR(path.ch, layer = "lakes"))
ogrListLayers(path.ch)
path.ch <- getPathShp('CH')
ch <- readOGR(path.ch, layer = 'municipalities-without-lakes')
ch.df <- formatShp(ch)
ch.communes <- ggplot(ch.df, aes(x = long, y = lat, group = group)) + geom_polygon(size = 0.01, aes(fill = GEMNAME)) +
theme_minimal() + theme(legend.position = "none", panel.grid = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), axis.text = element_blank())
ch.communes
lake.df <- formatShp(readOGR(path.ch, layer = "lakes"))
ogrListLayers(file.path(path.ch, "ch-country.ch"))
ogrListLayers(file.path(path.ch, "ch-country.ch"))
path.ch
require(rgdal)
require(rgeos)
require(ggplot2)
path <- getPathShp('world')
layers <- getShpLayers(path)
# read shapefiles for given layer
world <- readOGR(path, layer = layers[1])
world.df <- formatShp(world)
# plot world map
ggplot(world.df, aes(x = long, y = lat, group = group)) + geom_polygon(size = 0.01, aes(fill = FIPS)) +
theme_minimal() + theme(legend.position = "none", panel.grid = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), axis.text = element_blank())
Same with swiss commune map (slow!)
## Not run:
path.ch <- getPathShp('CH')
ch <- readOGR(path.ch, layer = 'municipalities')
ch.df <- formatShp(ch)
# plot swiss commune map
ch.communes <- ggplot(ch.df, aes(x = long, y = lat, group = group)) + geom_polygon(size = 0.01, aes(fill = GEMNAME)) +
theme_minimal() + theme(legend.position = "none", panel.grid = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), axis.text = element_blank())
ch.communes
# add the lake and country contours
lake.df <- formatShp(readOGR(path.ch, layer = "lakes"))
country.layers
ch.communes + geom_polygon(data = country.df, fill = NA, color = "black", size = 2) + geom_polygon(data = lake.df, fill = "lightgrey", colour = "lightgrey")
country.df <- readOGR(file.path(path.ch, "ch-country.json"), country.layers[1])
library(swiMap)
library(swiMap)
ch.communes + geom_polygon(data = country.df, fill = NA, color = "black", size = 0.1) + geom_polygon(data = lake.df, fill = "lightgrey", colour = "lightgrey")
ch.communes + geom_polygon(data = lake.df, fill = "blue", colour = "blue")
ch.communes <- ggplot(ch.df, aes(x = long, y = lat, group = group)) + geom_polygon(size = 0, aes(fill = GEMNAME)) +
theme_minimal() + theme(legend.position = "none", panel.grid = element_blank(), axis.ticks = element_blank(), axis.title = element_blank(), axis.text = element_blank())
ch.communes
bfsnName <- ch.df[!duplicated(ch.df$BFSNR),c('BFSNR', 'GEMNAME')]
bfsnName[order(bfsnName[,1]),]
library(swiMap)
library(swiMap)
library(swiMap)
library(swiMap)
library(swiMap)
countryTranslations  <- read.csv(system.file("extdata", "countrynames.csv", package="swiMap"))
library(swiMap)
query = c('AF', 'FR', 'US', 'CH', 'JP')
nchar
sapply(query, nchart)
sapply(query, nchar)
sapply(query, nchar)
sapply(query, nchar) <= 3
countryTranslations
str()
str(countryTranslations)
library(swiMap)
library(swiMap)
countryTranslations  <- read.csv(system.file("extdata", "countrynames.csv", package="swiMap"))
countryTranslations
str(countryTranslations)
countryTranslations  <- read.csv(system.file("extdata", "countrynames.csv", package="swiMap"), stringsAsFactors = FALSE)
countryTranslations
colnames(countryTranslations)
c(("EN", "DE", "FR", "IT", "SP", "PT","RU", "CH", "JP","AR"))
c("EN", "DE", "FR", "IT", "SP", "PT","RU", "CH", "JP","AR")
output = "EN"
output %in% colnames(countryTranslations)
match(query, countryTranslations[,1])
match(query, countryTranslations[,1:3])
match(query, countryTranslations[,1])
match(query, countryTranslations[,2])
sapply(query, nchar) <= 3
sapply(query, nchar) == 2
all(sapply(query, nchar) == 2)
grepl("^\\d+", query)
all(grepl("^\\d+", query))
!all(grepl("^\\d+", query))
idx.row <- match(query, countryTranslations[,1])
if(all(sapply(query, nchar) == 2)) {
idx.row <- match(query, countryTranslations[,1])
} else if (all(sapply(query, nchar) == 3) || !all(grepl("^\\d+", query))) {
idx.row <- match(query, countryTranslations[,2])
} else if (all(sapply(query, nchar) == 3) && all(grepl("^\\d+", query))) {
idx.row <- match(query, countryTranslations[,3])
} else {
stop("query format not valid!")
}
idx.row
match(output, colnames(countryTranslations))
countryTranslations[idx.row, match(output, colnames(countryTranslations))]
match(output, colnames(countryTranslations))
isoCol <- ''
if(all(sapply(query, nchar) == 2)) {
idx.row <- match(query, countryTranslations[,1])
isoCol <- 1
} else if (all(sapply(query, nchar) == 3) || !all(grepl("^\\d+", query))) {
idx.row <- match(query, countryTranslations[,2])
isoCol <- 2
} else if (all(sapply(query, nchar) == 3) && all(grepl("^\\d+", query))) {
idx.row <- match(query, countryTranslations[,3])
isoCol <- 3
} else {
stop("query format not valid!")
}
countryTranslations[idx.row, c(isoCol, match(output, colnames(countryTranslations)))]
library(swiMap)
countryTranslations[idx.row, match(output, colnames(countryTranslations))]
data.frame(countryTranslations[idx.row, match(output, colnames(countryTranslations))])
as.data.frame(countryTranslations[idx.row, match(output, colnames(countryTranslations))])
result <- cbind(code = query, countryTranslations[idx.row, match(output, colnames(countryTranslations))])
result
colnames(result)[-1]
colnames(result)[-1] <- output
result
library(swiMap)
countryTranslations  <- read.csv(system.file("extdata", "countrynames.csv", package="swiMap"), stringsAsFactors = FALSE, check.names = F)
countryTranslations
devtools::load_all(".")
countryTranslations  <- read.csv(system.file("extdata", "countrynames.csv", package="swiMap"), stringsAsFactors = FALSE, check.names = F,  na.strings = c("NA"))
countryTranslations
countryTranslations  <- read.csv(system.file("extdata", "countrynames.csv", package="swiMap"), stringsAsFactors = FALSE, check.names = F,  na.strings = "")
countryTranslations
library(swiMap)
?testInheritedMethods
library(swiMap)
library(swiMap)
library(swiMap)
library(swiMap)
test <- loadCommunesCHportraits()
library(swiMap)
loadCommunesCHportraits
test <- loadCommunesCHportraits()
str(test)
head(test)
attr(test)
attributes(test)
?attributes
test
dd<- test[-(1:2)]
str(dd)
as.matrix(dd)
dddata.matrix(test[-c(1:2),])
dd<- data.matrix(test[-c(1:2),])
warnings()
str(dd)
head(dd)
dd<- data.matrix(test[,-c(1:2)])
str(dd)
warnings()
test[,-c(1:2)]
data.matrix(test[,-c(1:2)])
warnings()
str(dd)
data.read[,1]
data.path <- dir(system.file("extdata", package="swiMap"), "communesCH_2015_indicators_je-f-21.03.01.csv", full.names = T)
data.read <- read.csv(data.path, skip = 2, header = TRUE, stringsAsFactors = F, check.names = FALSE)
data <- data.matrix(data.read[,-c(1:2)])
# rownames are commune BFS code
rownmaes(data) <- data.read[,1]
# attr communeName is the text name
attr(data, "communeName") <- data.read[,2]
rownames(data) <- data.read[,1]
# attr communeName is the text name
attr(data, "communeName") <- data.read[,2]
str(data)
metadata <- read.csv(data.path, nrows = 2, header = TRUE, stringsAsFactors = F, check.names = FALSE)
str(metadata)
metadata <- read.csv(data.path, nrows = 2, header = TRUE, stringsAsFactors = F, check.names = FALSE)
str(metadata)
metadata <- read.csv(data.path, nrows = 1, header = TRUE, stringsAsFactors = F, check.names = FALSE)
str(metadata)
metadata <- read.csv(data.path, nrows = 1, header = TRUE, stringsAsFactors = F, check.names = FALSE)[-c(1:2),]
str(metadata)
metadata <- read.csv(data.path, nrows = 1, header = TRUE, stringsAsFactors = F, check.names = FALSE)
metadata <- metadata[,-c(1:2)]
str(metadata)
metadata <- read.csv(data.path, nrows = 1, header = TRUE, stringsAsFactors = F, check.names = FALSE)
str(metadata)
metadata[1,]
metadata[,1]
metadata <- read.csv(data.path, nrows = 1, header = TRUE, stringsAsFactors = F, check.names = FALSE)
metadata
metadata <- read.csv(data.path, nrows = 1, header = TRUE, stringsAsFactors = F, check.names = FALSE)
metadata
c(metadata)
attr(data, "indicatorYear") <- metadata
str(data)
metadata
as.vector(metadata)
as.vector(metadata)[-c(1:2)]
attr(data, "indicatorYear") <- as.vector(metadata)[-c(1:2)]
str(data)
as.vector(metadata)[-c(1:2)]
unlist(metadata)[-c(1:2)]
attr(data, "indicatorYear") <- unlist(metadata)[-c(1:2)]
str(data)
names(metadata)
names(metadata))[-c(1:2)]
names(metadata)[-c(1:2)]
library(swiMap)
test <- loadCommunesCHportraits()
str(test)
head(test)
library(swiMap)
attr(test, "indicatorGroup")
which(attr(communeData, "indicatorGroup") == "Surface")
communeData <- loadCommunesCHportraits()
which(attr(communeData, "indicatorGroup") == "Surface")
communeData[,which(attr(communeData, "indicatorGroup") == "Surface")]
head(communeData[,which(attr(communeData, "indicatorGroup") == "Surface")])
tail(communeData)
colIdx <- which(attr(communeData, "indicatorGroup") == "Surface")
head(communeData[,colIdx])
library(swiMap)
?loadCommunesCHportraits
loadCommunesCHdata <- function(start = Sys.Date(), end = Sys.Date())
)
communesCH <- loadCommunesCHdata(start = Sys.Date(), end = Sys.Date())
str(communesCH)
loadCommunesCHdata(start = "2015-01-01", end = Sys.Date())
communesCH <- loadCommunesCHdata(start = "2012-01-01", end = Sys.Date())
communesCH
library(swiMap)
communesCH <- loadCommunesCHdata(start = "1901-01-01", end = Sys.Date())
which(communesCH$GBFSNR == '5724')
communesCH[which(communesCH$GBFSNR == '5724'),]
communeData <- loadCommunesCHportraits()
head(communeData)
head(rownames(communeData))
head(attr(communeData, "communeName"))
library(swiMap)
communeData <- loadCommunesCHportraits()
test <- read.csv("~/PLZO_CSV_LV03 copy.csv",  header = TRUE, stringsAsFactors = F, check.names = FALSE)
test <- read.csv("~/Desktop/PLZO_CSV_LV03 copy.csv",  header = TRUE, stringsAsFactors = F, check.names = FALSE)
str(test)
test <- read.csv("~/Desktop/PLZO_CSV_LV03 copy.csv", sep = ";", header = TRUE, stringsAsFactors = F, check.names = FALSE)
loadCommunesCHportraits <- function() {
str(test)
test <- read.csv("~/Desktop/PLZO_CSV_LV03 copy.csv", sep = ";", header = TRUE, stringsAsFactors = F, check.names = FALSE, encoding = "latin1")
str(test)
match(test$Gemeindename, rownames(communeData))
str(test$Gemeindename)
rownames(communeData)
match(test$Gemeindename, attr(communeData, "communeName"))
is.na(match(test$Gemeindename, attr(communeData, "communeName")))
sum(is.na(match(test$Gemeindename, attr(communeData, "communeName"))))
library(swiMap)
test <- read.csv("~/Desktop/PLZO_CSV_LV03 copy.csv", sep = ";", header = TRUE, stringsAsFactors = F, check.names = FALSE, encoding = "latin1")
test <- read.csv("~/Desktop/PLZO_CSV_LV03.csv", sep = ";", header = TRUE, stringsAsFactors = F, check.names = FALSE, encoding = "latin1")
sum(is.na(match(test$Gemeindename, attr(communeData, "communeName"))))
sum(is.na(match(attr(communeData, "communeName"), test$Gemeindename)))
which(is.na(match(attr(communeData, "communeName"), test$Gemeindename)))
library(swiMap)
library(swiMap)
?loadCHzipcode
library(swiMap)
communeData <- loadCommunesCHportraits()
colnames(communeData)
rownames(communeData)
# Select only "surface" indicators
colIdx <- which(attr(communeData, "indicatorGroup") == "Surface")
head(communeData[,colIdx])
zipcode <- loadCHzipcode()
match(zipcode$Gemeindename, attr(communeData, "communeName")
library(swiMap)
communeData <- loadCommunesCHportraits()
colnames(communeData)
rownames(communeData)
# Select only "surface" indicators
colIdx <- which(attr(communeData, "indicatorGroup") == "Surface")
head(communeData[,colIdx])
zipcode <- loadCHzipcode()
match(zipcode$Gemeindename, attr(communeData, "communeName")
)
library(swiMap)
library(swiMap)
install.packages("rmarkdown")
str(data)
ls()
?theme_set
??theme_set
library(swiMap)
library(swiMap)
